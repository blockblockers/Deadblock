import{a6 as y,a7 as G,$ as k}from"./index-8HZmLUul.js";const q="sb-oyeibyrednwlolmsjlwk-auth-token",p="https://oyeibyrednwlolmsjlwk.supabase.co",O="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im95ZWlieXJlZG53bG9sbXNqbHdrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUyMzMyNzQsImV4cCI6MjA4MDgwOTI3NH0.GNMI2HOyOn_YHPPgsrkinB5FipLedqo0bTN9PKRQJMY",f=()=>{const b=JSON.parse(localStorage.getItem(q)||"null");return!b?.access_token||!O?null:{Authorization:`Bearer ${b.access_token}`,apikey:O,"Content-Type":"application/json",Prefer:"return=representation"}};class E{constructor(){this.currentGameId=null,this.unsubscribeHandler=null}subscribeToGame(e,r,a){if(!y)return{unsubscribe:()=>{}};if(typeof r!="function")return console.error("[GameSync] subscribeToGame: onUpdate must be a function"),{unsubscribe:()=>{}};this.unsubscribe(),this.currentGameId=e,G.connectGame(e);const t=i=>{try{typeof r=="function"&&r(i)}catch(n){console.error("[GameSync] Handler error:",n),typeof a=="function"&&a(n)}};return this.unsubscribeHandler=G.on("gameUpdate",t),{unsubscribe:()=>this.unsubscribe()}}unsubscribe(){this.unsubscribeHandler&&(this.unsubscribeHandler(),this.unsubscribeHandler=null),G.disconnectGame(),this.currentGameId=null}async getGame(e){if(!y)return{data:null,error:{message:"Not configured"}};const r=f();if(!r)return console.error("gameSync.getGame: No auth token"),{data:null,error:{message:"Not authenticated"}};const a={...r};a.Accept="application/vnd.pgrst.object+json";try{const t=await fetch(`${p}/rest/v1/games?id=eq.${e}&select=*`,{headers:a});if(!t.ok){const d=await t.text();return console.error("gameSync.getGame: Fetch failed:",d),{data:null,error:{message:`Failed to fetch game: ${t.status}`}}}const i=await t.json();let n=null,c=null;const s=[i.player1_id,i.player2_id].filter(Boolean);if(s.length>0){const d={...r};delete d.Accept;const o=await fetch(`${p}/rest/v1/profiles?id=in.(${s.join(",")})&select=*`,{headers:d});if(o.ok){const l=await o.json();n=l?.find(u=>u.id===i.player1_id)||null,c=l?.find(u=>u.id===i.player2_id)||null}}return{data:{...i,player1:n,player2:c},error:null}}catch(t){return console.error("gameSync.getGame: Exception:",t.message),{data:null,error:{message:t.message}}}}getPlayerNumber(e,r){return!e||!r?null:e.player1_id===r?1:e.player2_id===r?2:null}isPlayerTurn(e,r){if(!e||!r||e.status!=="active")return!1;const a=this.getPlayerNumber(e,r);return e.current_player===a}async getLastMove(e){if(!y)return{data:null,error:{message:"Not configured"}};const r=f();if(!r)return{data:null,error:{message:"Not authenticated"}};try{const a={...r};a.Accept="application/vnd.pgrst.object+json";const t=await fetch(`${p}/rest/v1/game_moves?game_id=eq.${e}&order=move_number.desc&limit=1`,{headers:a});return t.ok?{data:await t.json(),error:null}:t.status===406?{data:null,error:null}:{data:null,error:{message:`Failed to fetch last move: ${t.status}`}}}catch(a){return console.error("gameSync.getLastMove: Exception:",a.message),{data:null,error:{message:a.message}}}}async makeMove(e,r,a){if(!y)return{error:{message:"Not configured"}};const t=f();if(!t)return console.error("gameSync.makeMove: No auth token"),{data:null,error:{message:"Not authenticated"}};const{pieceType:i,row:n,col:c,rotation:s,flipped:d,newBoard:o,newBoardPieces:l,newUsedPieces:u,nextPlayer:_,gameOver:w,winnerId:g}=a;try{const m={...t};m.Prefer="count=exact",m["Range-Unit"]="items",m.Range="0-0";let N=0;try{const S=(await fetch(`${p}/rest/v1/game_moves?game_id=eq.${e}&select=id`,{headers:m,method:"HEAD"})).headers.get("content-range");if(S){const j=S.match(/\/(\d+)/);j&&(N=parseInt(j[1],10))}}catch{}const A={game_id:e,player_id:r,piece_type:i,row:n,col:c,rotation:s||0,flipped:d||!1,move_number:N+1};try{const h=await fetch(`${p}/rest/v1/game_moves`,{method:"POST",headers:t,body:JSON.stringify(A)});if(!h.ok){const S=await h.text();console.error("gameSync.makeMove: Error recording move:",S)}}catch(h){console.warn("gameSync.makeMove: Could not record move history:",h.message)}const $={board:o,board_pieces:l,used_pieces:u,current_player:_,turn_started_at:new Date().toISOString(),updated_at:new Date().toISOString()};w&&($.status="completed",$.winner_id=g||null);const P={...t};P.Accept="application/vnd.pgrst.object+json";const v=await fetch(`${p}/rest/v1/games?id=eq.${e}`,{method:"PATCH",headers:P,body:JSON.stringify($)});if(!v.ok){const h=await v.text();return console.error("gameSync.makeMove: Game update failed:",h),{data:null,error:{message:`Game update failed: ${v.status}`}}}const H=await v.json();return w&&g&&await this.updatePlayerStats(e,g),{data:H,error:null}}catch(m){return console.error("gameSync.makeMove: Exception:",m.message),{data:null,error:{message:m.message}}}}async updatePlayerStats(e,r){if(y)try{const{data:a}=await this.getGame(e);if(!a)return;const t=a.player1_id,i=a.player2_id,n=r===t?i:t,c=f();if(!c)return;try{const s=await fetch(`${p}/rest/v1/rpc/update_ratings_after_game`,{method:"POST",headers:c,body:JSON.stringify({p_game_id:e,p_winner_id:r})});if(!s.ok){const d=await s.text();console.error("gameSync.updatePlayerStats: ELO update failed:",d)}}catch(s){console.error("gameSync.updatePlayerStats: ELO update exception:",s.message)}await fetch(`${p}/rest/v1/rpc/increment_wins`,{method:"POST",headers:c,body:JSON.stringify({p_user_id:r})}).catch(()=>{}),await fetch(`${p}/rest/v1/rpc/increment_losses`,{method:"POST",headers:c,body:JSON.stringify({p_user_id:n})}).catch(()=>{})}catch(a){console.error("gameSync.updatePlayerStats: Error:",a.message)}}async getActiveGames(e){if(!y||!e)return{data:[],error:null};const r=f();if(!r)return{data:[],error:{message:"Not authenticated"}};try{const a=await fetch(`${p}/rest/v1/games?or=(player1_id.eq.${e},player2_id.eq.${e})&status=eq.active&order=updated_at.desc&select=*`,{headers:r});if(!a.ok)return{data:[],error:{message:"Failed to fetch games"}};const t=await a.json(),i=t.map(n=>n.player1_id===e?n.player2_id:n.player1_id).filter(Boolean);if(i.length>0){const n=[...new Set(i)],c=await fetch(`${p}/rest/v1/profiles?id=in.(${n.join(",")})&select=id,username,display_name,rating`,{headers:r});if(c.ok){const s=await c.json(),d={};s.forEach(o=>{d[o.id]=o}),t.forEach(o=>{o.player1=d[o.player1_id]||null,o.player2=d[o.player2_id]||null;const l=o.player1_id===e?o.player2_id:o.player1_id;o.opponent=d[l]||null})}}return{data:t,error:null}}catch(a){return console.error("[GameSync] getActiveGames: Exception:",a.message),{data:[],error:{message:a.message}}}}async markResultViewed(e,r){if(!k()||!e||!r)return{success:!1};const a=f();if(!a)return{success:!1,error:"Not authenticated"};try{return(await fetch(`${p}/rest/v1/rpc/mark_game_result_viewed`,{method:"POST",headers:a,body:JSON.stringify({p_game_id:e,p_user_id:r})})).ok?{success:!0}:(console.error("[GameSync] Failed to mark result viewed"),{success:!1})}catch(t){return console.error("[GameSync] Error marking result viewed:",t),{success:!1,error:t.message}}}async getActiveAndUnviewedGames(e){if(!k()||!e)return{data:[],error:null};const r=f();if(!r)return{data:[],error:"Not authenticated"};try{const a=await fetch(`${p}/rest/v1/games?or=(player1_id.eq.${e},player2_id.eq.${e})&status=eq.active&order=updated_at.desc&select=*`,{headers:r});let t=[];a.ok&&(t=await a.json());let i=[];try{const s=await fetch(`${p}/rest/v1/rpc/get_unviewed_completed_games`,{method:"POST",headers:r,body:JSON.stringify({p_user_id:e})});if(s.ok){const d=await s.json();d&&d.length>0&&(i=d.map(o=>({...o,_isUnviewedResult:!0,_isLoss:o.is_loss})))}}catch{console.log("[GameSync] get_unviewed_completed_games RPC not available yet")}const n=[...t,...i],c=n.map(s=>s.player1_id===e?s.player2_id:s.player1_id).filter(Boolean);if(c.length>0){const s=[...new Set(c)],d=await fetch(`${p}/rest/v1/profiles?id=in.(${s.join(",")})&select=id,username,display_name,rating,elo_rating`,{headers:r});if(d.ok){const o=await d.json(),l={};o.forEach(u=>{l[u.id]=u}),n.forEach(u=>{u.player1=l[u.player1_id]||null,u.player2=l[u.player2_id]||null;const _=u.player1_id===e?u.player2_id:u.player1_id;u.opponent=l[_]||null})}}return{data:n,error:null}}catch(a){return console.error("[GameSync] getActiveAndUnviewedGames: Exception:",a.message),{data:[],error:{message:a.message}}}}async getPlayerGames(e,r=10){if(!y||!e)return{data:[],error:null};const a=f();if(!a)return{data:[],error:{message:"Not authenticated"}};try{const t=await fetch(`${p}/rest/v1/games?or=(player1_id.eq.${e},player2_id.eq.${e})&status=eq.completed&order=updated_at.desc&limit=${r}&select=*`,{headers:a});if(!t.ok)return{data:[],error:{message:"Failed to fetch games"}};const i=await t.json(),n=new Set;if(i.forEach(c=>{c.player1_id&&n.add(c.player1_id),c.player2_id&&n.add(c.player2_id)}),n.size>0){const c=[...n],s=await fetch(`${p}/rest/v1/profiles?id=in.(${c.join(",")})&select=id,username,display_name,rating`,{headers:a});if(s.ok){const d=await s.json(),o={};d.forEach(l=>{o[l.id]=l}),i.forEach(l=>{l.player1=o[l.player1_id]||null,l.player2=o[l.player2_id]||null;const u=l.player1_id===e?l.player2_id:l.player1_id;l.opponent=o[u]||null})}}return{data:i,error:null}}catch(t){return console.error("[GameSync] getPlayerGames: Exception:",t.message),{data:[],error:{message:t.message}}}}async forfeitGame(e,r){if(!y||!e||!r)return{error:{message:"Invalid parameters"}};const a=f();if(!a)return{error:{message:"Not authenticated"}};try{const{data:t}=await this.getGame(e);if(!t)return{error:{message:"Game not found"}};const i=t.player1_id===r?t.player2_id:t.player1_id,n={...a};n.Accept="application/vnd.pgrst.object+json";const c=await fetch(`${p}/rest/v1/games?id=eq.${e}`,{method:"PATCH",headers:n,body:JSON.stringify({status:"completed",winner_id:i,updated_at:new Date().toISOString()})});return c.ok?(await this.updatePlayerStats(e,i),{data:await c.json(),error:null}):{error:{message:"Failed to forfeit game"}}}catch(t){return{error:{message:t.message}}}}async abandonGame(e){if(!y||!e)return{error:{message:"Invalid parameters"}};const r=f();if(!r)return{error:{message:"Not authenticated"}};try{const a={...r};a.Accept="application/vnd.pgrst.object+json";const t=await fetch(`${p}/rest/v1/games?id=eq.${e}`,{method:"PATCH",headers:a,body:JSON.stringify({status:"abandoned",updated_at:new Date().toISOString()})});return t.ok?{data:await t.json(),error:null}:{error:{message:"Failed to abandon game"}}}catch(a){return{error:{message:a.message}}}}async checkAndForfeitStaleGames(e){if(!k()||!e)return{forfeited:[]};try{const r=f();if(!r)return{forfeited:[]};const a=new Date(Date.now()-14*24*60*60*1e3).toISOString(),t=`${p}/rest/v1/games?select=*,player1:profiles!games_player1_id_fkey(id,username,display_name,rating),player2:profiles!games_player2_id_fkey(id,username,display_name,rating)&status=eq.active&or=(player1_id.eq.${e},player2_id.eq.${e})&updated_at=lt.${a}`,i=await fetch(t,{headers:r});if(!i.ok)return{forfeited:[]};const n=await i.json(),c=[];for(const s of n){const d=s.current_player===1?s.player1_id:s.player2_id,o=s.current_player===1?s.player2_id:s.player1_id,l=d,u=`${p}/rest/v1/games?id=eq.${s.id}`;if((await fetch(u,{method:"PATCH",headers:{...r,Prefer:"return=minimal"},body:JSON.stringify({status:"completed",winner_id:o,forfeit_reason:"inactivity",updated_at:new Date().toISOString()})})).ok){const w=l===s.player1_id?s.player1?.rating||1e3:s.player2?.rating||1e3,g=Math.max(100,w-15),m=`${p}/rest/v1/profiles?id=eq.${l}`;await fetch(m,{method:"PATCH",headers:{...r,Prefer:"return=minimal"},body:JSON.stringify({rating:g})}),c.push({gameId:s.id,loserId:l,winnerId:o,reason:"inactivity"})}}return{forfeited:c}}catch(r){return console.error("[GameSync] checkAndForfeitStaleGames error:",r),{forfeited:[]}}}}const T=new E;export{T as g};
